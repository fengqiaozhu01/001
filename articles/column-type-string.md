# 史上最简单的 MySQL 教程（十一）「列类型 之 字符串型」

列类型（数据类型）
=========
所谓的列类型，其实就是指数据类型，即对数据进行统一的分类，从系统的角度出发是为了能够使用统一的方式进行管理，更好的利用有限的空间。

在 SQL 中，将数据类型分成了三大类，分别为：**数值型、字符串型和日期时间型。**

![1](http://img.blog.csdn.net/20170505201016682)

字符串型
---

在 SQL 中，将字符串类型分成了 6 类，分别为：`char`、`varchar`、`text`、`blob`、`enum`和`set`.

**第 1 类：定长字符串**

定长字符串：`char`，即磁盘（二维表）在定义结构的时候就已经确定了最终数据的存储长度。

 - `char(L)`：L 表示 Length，即可以存储的长度，单位为字符，最大长度为 255；
 - `char(4)`：表示在 UTF8 环境下，需要 4*3=12 个字节。

**第 2 类：变长字符串**

变长字符串：`varchar`，即在分配存储空间的时候，按照最大的空间分配，但是实际用了多少，则是根据具体的数据来确定。

 - `varchar(L)`：L 表示 Length，理论长度是 65536，但是会多出 1 到 2 个字节来确定存储的实际长度；
 - `varchar(10)`：例如存储 10 个汉字，在 UTF8 环境下，需要 10*3+1=31 个字节。

实际上，如果存储长度超过 255 个字符，则既不用定长字符串也不用变长字符串，而是用文本字符串`text`.

如何选择定长字符串或者是变长字符串呢？

 - 定长字符串对磁盘空间比较浪费，但是效率高：如果数据基本上确定长度都一样，就使用定长字符串，例如身份证、电话号码等；
 - 变长字符串对磁盘空间比较节省，但是效率低：如果数据不能确定长度（不同的数据有变化），就使用变长字符串，例如地址、姓名等。

**第 3 类：文本字符串**

如果数据量非常大，通常说超过 255 个字符就会使用文本字符串。

文本字符串根据存储的格式进行分类，可以分为：

 - `text`：存储文字；
 - `blob`：存储二进制数据（其实际上都是存储路径），通常不用。

**第 4 类：枚举字符串**

枚举字符串：`enum`，需要事先将所有可能出现的结果都设计好，实际上存储的数据必须是规定好的数据中的一个。

枚举字符串的使用方式：

 - 定义：`enum('元素1','元素2','元素3'...)`，例如`enum('男','女','保密')`；
 - 使用：存储的数据，只能是事先定义好的数据。

执行如下 SQL 语句创建枚举表，进行测试：

```
-- 创建枚举表
create table my_enum(
	gender enum('男','女','保密')
)charset utf8;
```

![2](http://img.blog.csdn.net/20170521214843424)

再执行如下 SQL 语句，向表`my_enum`中插入测试数据：

```
-- 插入测试数据
insert into my_enum values ('男'),('女'),('保密');
insert into my_enum values ('male');
```
![3](http://img.blog.csdn.net/20170521215211842)

通过上面的测试，咱们可以发现使用枚举字符串有一个好处，那就是：**规范数据格式，插入表中的数据只能是事先定义好的某个数据。**

此外，枚举字符串还有一个作用，那就是：**节省存储空间（枚举数据通常都有一个别名），枚举实际上存储的是数值而不是字符串本身。**

在 MySQL 中，系统是有自动转换数据格式的功能的。在这里，咱们可以证明枚举字段存储的是数值，具体方法为：将数据取出来`+0`，如果是字符串最终结果永远为`0`，否则就是其他值。

```
-- 验证枚举字段实际存储的格式
select gender + 0,gender from my_enum;
```

![4](http://img.blog.csdn.net/20170521220113393)

观察上述结果，咱们可以找出枚举元素的实际规律，即按照元素出现的顺序，从`1`开始编号。接下来，咱们再来了解**枚举的原理**：

 - 枚举在进行数据规范（定义）的时候，系统会自动建立一个数字与枚举元素的对应关系（放在日志中）；在进行数据插入的时候，系统自动将字符串转换为对应的数值进行存储；在进行数据提取的时候，系统自动将数值转换成对应的字符串进行显示。

通过阅读以上枚举的原理，咱们可以知道：**使用枚举的效率并不高（低于其他类型的数据），但能规范数据和节省存储空间。**

**第 5 类：集合字符串**

集合字符串：`set`，跟枚举类似，实际存储的是数值而不是字符串。

集合字符串的使用方式：

 - 定义：`set`，元素列表；
 - 使用：可以使用元素列表中的多个元素，用逗号分隔。

执行如下 SQL 语句创建枚举表，进行测试：

```
-- 创建集合表
create table my_set(
	hobby set('音乐','电影','旅行','美食','摄影','运动','宠物')
)charset utf8;
```

![5](http://img.blog.csdn.net/20170521223557192)

再执行如下 SQL 语句，向表`my_set`中插入测试数据：
```
-- 插入测试数据
insert into my_set values ('电影,美食,宠物');
insert into my_set values (3);
```

![6](http://img.blog.csdn.net/20170521223912147)

再执行如下 SQL 语句，查看表`my_set`中的数据：

```
-- 查看数据
select hobby + 0,hobby from my_set;
```

![7](http://img.blog.csdn.net/20170521224106226)

观察上面的结果，相信大部分童鞋也懵啦！对于`3`还好理解，`3=2+1`，对应于集合中数据的编号，也正是`音乐`和`电影`；但是`74`是什么鬼啊？在此，咱们不妨将集合（`'音乐','电影','旅行','美食','摄影','运动','宠物'`）中的元素选中的记为`1`，没有选中的记为`0`，表示成二进制，也就是：

 - `0101001`

再将上面的二进制反过来：

 - `1001010`

不妨算算，上述二进制对应的十进制数，即为`74`.

到这里，相信大家已经恍然大悟啦，原来：**集合字符串中每一个元素都对应一个二进制位，其中被选中的为`1`，未选中的为`0`，最后在反过来，这个二进制数对应的十进制数即为其数据库中实际存储的是数值。**

此外，集合字符串中插入元素的顺序并没有影响，最终系统都会自动去匹配集合的顺序，即：

```
-- 插入测试数据
insert into my_set values ('电影,美食,旅行');
insert into my_set values ('旅行,电影,美食');
```

上述两个 SQL 语句会产生相同的结果：

![8](http://img.blog.csdn.net/20170521230456356)

如上图所示，显然咱们的结论得到了验证。

最后，集合的原理同枚举类似，因此可以的到相同的结论，即：**使用集合的效率并不高（低于其他类型的数据），但能规范数据和节省存储空间。**








----------
———— ☆☆☆ —— [返回 -> 史上最简单的 MySQL 教程 <- 目录](https://github.com/guobinhit/mysql-tutorial/blob/master/README.md) —— ☆☆☆ ————
